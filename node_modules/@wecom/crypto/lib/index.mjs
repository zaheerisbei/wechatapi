import { createHash, createDecipheriv, randomBytes, createCipheriv } from 'crypto';

/**
 * 获取签名
 *
 * @param token     Token
 * @param timestamp 时间戳
 * @param nonce     随机串
 * @param encrypt   密文
 */
function getSignature(token, timestamp, nonce, encrypt) {
    return createHash('sha1')
        .update([token, timestamp, nonce, encrypt].sort().join(''))
        .digest('hex');
}
/**
 * 解密
 *
 * @param encodingAESKey EncodingAESKey
 * @param encrypt        密文
 */
function decrypt(encodingAESKey, encrypt) {
    const { key, iv } = parseEncodingAESKey(encodingAESKey);
    const decipher = createDecipheriv('aes-256-cbc', key, iv);
    decipher.setAutoPadding(false);
    const deciphered = pkcs7Unpad(Buffer.concat([
        decipher.update(encrypt, 'base64'),
        decipher.final(),
    ]));
    const length = deciphered.readUInt32BE(16);
    return {
        message: deciphered.slice(20, length + 20).toString(),
        id: deciphered.slice(length + 20).toString(),
        random: deciphered.slice(0, 16),
    };
}
/**
 * 加密
 *
 * @param encodingAESKey EncodingAESKey
 * @param message        消息文本
 * @param id             ID
 * @param random         随机串
 */
function encrypt(encodingAESKey, message, id, random = randomBytes(16)) {
    const { key, iv } = parseEncodingAESKey(encodingAESKey);
    const msg = Buffer.from(message);
    const msgLength = Buffer.allocUnsafe(4);
    msgLength.writeUInt32BE(msg.length, 0);
    const deciphered = pkcs7Pad(Buffer.concat([
        random,
        msgLength,
        msg,
        Buffer.from(id),
    ]));
    const cipher = createCipheriv('aes-256-cbc', key, iv);
    cipher.setAutoPadding(false);
    const ciphered = Buffer.concat([
        cipher.update(deciphered),
        cipher.final(),
    ]);
    // 返回加密数据的base64编码
    return ciphered.toString('base64');
}
/**
 * 获取 JSAPI 签名
 *
 * @param options 签名相关参数
 */
function getJsApiSignature(options) {
    const { url, ticket } = options;
    const nonceStr = options.nonceStr || Math.random().toString(36).slice(2);
    const timestamp = options.timestamp || Math.floor(Date.now() / 1000);
    const signature = createHash('sha1')
        .update(`jsapi_ticket=${ticket}&noncestr=${nonceStr}&timestamp=${timestamp}&url=${url}`)
        .digest('hex');
    return { timestamp, nonceStr, signature };
}
/**
 * @param data
 */
function pkcs7Unpad(data) {
    const padLength = data[data.length - 1];
    /* istanbul ignore if */
    if (padLength < 1 || padLength > 32) {
        return data;
    }
    return data.slice(0, data.length - padLength);
}
/**
 * @param data
 */
function pkcs7Pad(data) {
    const padLength = 32 - (data.length % 32);
    const result = Buffer.allocUnsafe(padLength);
    result.fill(padLength);
    return Buffer.concat([data, result]);
}
/**
 * 解码并校验 encodingAESKey
 *
 * @param encodingAESKey EncodingAESKey
 */
function parseEncodingAESKey(encodingAESKey) {
    const key = Buffer.from(`${encodingAESKey}=`, 'base64');
    /* istanbul ignore if */
    if (key.length !== 32) {
        throw new Error('invalid encodingAESKey');
    }
    const iv = key.slice(0, 16);
    return { key, iv };
}

export { decrypt, encrypt, getJsApiSignature, getSignature };
